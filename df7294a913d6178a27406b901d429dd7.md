# 代码审计报告




## 1. 漏洞简介


**漏洞名称**：优惠券系统 - 折扣使用限制竞态条件绕过



**漏洞描述**：
在DiscountService.cs的ValidateDiscountAsync方法中，折扣使用次数验证与使用记录之间存在竞态条件，攻击者可通过并发请求绕过折扣使用限制，导致折扣被超限使用。





## 2. 漏洞原理
1. **漏洞原理概述**
   折扣验证逻辑存在经典的TOCTOU（Time-of-Check-Time-of-Use）竞态条件，验证检查与使用记录之间存在时间窗口。

2. **具体代码分析**
   - **检查阶段** (DiscountService.cs:556, 566):
     ```csharp
     // 检查折扣使用次数
     var usedTimes = (await GetAllDiscountUsageHistoryAsync(discount.Id, null, null, false, 0, 1)).TotalCount;
     if (usedTimes >= discount.LimitationTimes)
         return result;
     ```
   - **使用阶段** (OrderProcessingService.cs:1440):
     ```csharp
     // 记录折扣使用历史
     await _discountService.InsertDiscountUsageHistoryAsync(new DiscountUsageHistory
     {
         DiscountId = d.Id,
         OrderId = order.Id,
         CreatedOnUtc = DateTime.UtcNow
     });
     ```

3. **竞态条件形成**
   - 多个并发请求同时通过使用次数验证
   - 所有请求在记录使用历史前都认为折扣可用
   - 最终导致折扣被使用次数超过限制





## 3. 漏洞风险


**风险等级：**HIGH



**风险描述：**
**潜在危害**：
- 财务损失：攻击者可无限次使用有限次数的优惠券，造成商家经济损失
- 营销活动失效：限量折扣活动被滥用，影响营销效果
- 数据一致性破坏：折扣使用统计数据不准确

**受影响资产**：
- 所有有限次使用的折扣和优惠券
- 商家财务收入
- 营销活动数据完整性

**业务影响**：
- 高：可直接导致财务损失和营销活动失败










## 5. 修复方案
1. **原子性检查与更新** (DiscountService.cs)
   在验证折扣时使用数据库事务和行级锁确保原子性：
   ```csharp
   public virtual async Task<bool> ValidateAndReserveDiscountAsync(Discount discount, Customer customer)
   {
       using var transaction = await _discountRepository.BeginTransactionAsync();
       try
       {
           // 使用FOR UPDATE锁定折扣记录
           var currentUsage = await _discountUsageHistoryRepository.Table
               .Where(duh => duh.DiscountId == discount.Id)
               .CountAsync();
               
           if (currentUsage >= discount.LimitationTimes)
               return false;
               
           // 立即预留使用记录
           await InsertDiscountUsageHistoryAsync(new DiscountUsageHistory
           {
               DiscountId = discount.Id,
               CustomerId = customer.Id,
               CreatedOnUtc = DateTime.UtcNow
           });
           
           await transaction.CommitAsync();
           return true;
       }
       catch
       {
           await transaction.RollbackAsync();
           return false;
       }
   }
   ```

2. **使用分布式锁** (OrderProcessingService.cs)
   在订单处理关键路径添加分布式锁：
   ```csharp
   public virtual async Task<PlaceOrderResult> PlaceOrderAsync(ProcessPaymentRequest processPaymentRequest)
   {
       var lockKey = $"discount_validation_{processPaymentRequest.CustomerId}";
       using var distributedLock = await _distributedLockService.AcquireLockAsync(lockKey, TimeSpan.FromSeconds(30));
       
       if (distributedLock == null)
           throw new Exception("无法获取分布式锁");
           
       // 原有的订单处理逻辑...
   }
   ```

3. **幂等性设计**
   为每个订单请求生成唯一幂等令牌，防止重复处理：
   ```csharp
   public virtual async Task<PlaceOrderResult> PlaceOrderAsync(ProcessPaymentRequest processPaymentRequest)
   {
       if (!string.IsNullOrEmpty(processPaymentRequest.IdempotencyKey))
       {
           var existingOrder = await _orderRepository.Table
               .FirstOrDefaultAsync(o => o.IdempotencyKey == processPaymentRequest.IdempotencyKey);
           if (existingOrder != null)
               return new PlaceOrderResult { PlacedOrder = existingOrder };
       }
       // 继续处理订单...
   }
   ```
